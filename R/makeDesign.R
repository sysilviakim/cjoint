#' Create Conjoint Design
#'
#' @param type A character string - either "file", "constraints", or "array".  
#' Each option requires a different set of additional arguments. 
#' If "file", the user must specify a filename of a ".dat" file exported 
#' via the Conjoint Survey Design Tool. If "constraints," the user must 
#' provide a list of attributes and levels in "attribute.levels" along with 
#' any constraints in "constraints" and attribute randomization weights in 
#' "level.probs". If "array," the user must pass an array to J.
#' 
#' @param J	If type = "array", makeDesign requires a d-dimensional array 
#' to be passed to J where d is the number of attributes in a single profile. 
#' Each dimension should have a number of indices corresponding to the number 
#' of levels for that attribute. Attribute and level names are taken from the 
#' dimnames of the array (level names are taken from the list elements, 
#' attribute names are taken from the names of the elements). 
#' Each cell of the array is the joint probability of assigning that 
#' particular profile (combination of attribute-levels).
#' 
#' @param filename If type="file", this is a character string giving the  
#' name of a design file exported from the Conjoint Survey Design Tool 
#' using the "Export design to R" option.
#' 
#' @param attribute.levels If type = "constraints", attribute.levels is a 
#' required argument. This takes a named list with each element containing a 
#' character vector with the level names of a single attribute. The names 
#' of the elements should be the attribute names.
#' 
#' @param constraints	If type = "constraints", this is an optional argument. 
#' A list of lists. Each element list is a "restriction" and describes a set 
#' of restricted profiles (attribute-level groupings that cannot be displayed 
#' to a respondent) with character vectors containing the attribute-levels 
#' that cannot be displayed together. If your design prevents certain 
#' profiles from being seen by respondents (for example, if the particular 
#' profile would be highly impluasible), this argument allows you to specify 
#' those restrictions. Each element of a restriction is a character vector of 
#' levels for a particular attribute. That element must have the name of one 
#' of the attributes. For each specified restriction, makeDesign will treat 
#' any profile containing any combination of the restricted levels as having 
#' zero probability of being displayed. For example, if a restriction 
#' contains two elements: A = c("1","2") and B = c("4", "5"), then any 
#' profiles containing levels 1 or 2 of attribute A and levels 4 or 5 of 
#' attribute B will restricted from the design.
#' 
#' @param level.probs If type = "constraints", this is an optional argument. 
#' A named list containing numeric vector elements. 
#' Each list element should have the name of one of the attributes passed 
#' in attribute.levels and the numeric vector it contains should have 
#' the names of the corresponding levels. Each element of the numeric vector 
#' specifies the marginal probability of that level appearing in a profile 
#' before any restricted profiles are eliminated. Each of the vectors 
#' should sum to 1. If NULL, then uniform randomization is assumed 
#' (excluding constrained profiles).
#' @param tol	A very small non-zero number used in the routine for 
#' determining which attributes are dependent (the distribution of 
#' one attribute depends on the value of another attribute). 
#' Two attributes are independent if the distribution of one attribute 
#' does not change conditional on the other - this is calculated 
#' automatically through the J matrix Do not change unless you are 
#' having issues with makeDesign incorrectly labeling independent attributes 
#' as dependent (in which case, lower the value) or incorrectly labeling 
#' dependent attributes as independent (in which case, raise the value).
#'
#' @importFrom methods Quote
#' @export makeDesign

makeDesign <- function(type = "file",
                       J = NULL,
                       filename = NULL,
                       attribute.levels = NULL,
                       constraints = NULL,
                       level.probs = NULL,
                       tol = 1e-14) {
  ## Initialize conjointDesign object
  design.obj <- NULL

  ## If type="file", then try to load from file generated by Conjoint SDT
  if (type == "file") {
    if (is.null(filename)) {
      cat("Error: Must provide a valid filename argument for type = 'file'\n")
      stop()
    }
    # Make a connection and read the lines
    connection <- file(filename, open = "r")
    file_lines <- readLines(connection)
    close(connection)
    attr_index <- which(file_lines == "Attributes")
    weight_index <- which(file_lines == "Weights")
    restriction_index <- which(file_lines == "Restrictions")

    attributes <- file_lines[(attr_index + 1):(weight_index - 1)]
    weight <- file_lines[(weight_index + 1):(restriction_index - 1)]
    if (restriction_index + 1 != length(file_lines)) {
      constr <- file_lines[(restriction_index + 1):length(file_lines)]
    } else {
      constr <- NULL
    }
    attribute.levels <- list()
    for (attrstr in attributes) {
      attributename <- strsplit(attrstr, ":")[[1]][1]
      levels <- strsplit(strsplit(attrstr, ":")[[1]][2], ",")[[1]]
      attribute.levels[[attributename]] <- levels
    }
    level.probs <- list()
    for (probstr in weight) {
      attributename <- strsplit(probstr, ":")[[1]][1]
      weights <- strsplit(strsplit(probstr, ":")[[1]][2], ",")[[1]]
      level.probs[[attributename]] <- as.numeric(weights)
    }
    if (is.null(constr) != TRUE) {
      constraints <- list()
      for (i in 1:length(constr)) {
        allconstraints <- strsplit(constr[i], ";")[[1]]
        constraints[[i]] <- list()
        for (m in allconstraints) {
          attributename <- strsplit(m, ":")[[1]][1]
          constrained_levels <- strsplit(strsplit(m, ":")[[1]][2], ",")[[1]]
          constraints[[i]][[attributename]] <- constrained_levels
        }
      }
    } else {
      constraints <- NULL
    }
  }

  ## if type = "array", check whether J is a valid array,
  ## then create conjointDesign object
  if (type == "array") {
    if (sum(J) != 1) {
      cat(
        paste0(
          "Error: Profile assignment probability array invalid: ",
          "Does not sum to 1\n"
        )
      )
    } else {
      design.obj$J <- J
      design.obj$dependence <- compute_dependencies(J)
    }
  } else if (type == "constraints" | type == "file") {
    ## if type = "constraints"
    if (is.null(attribute.levels) | is.list(attribute.levels) != TRUE) {
      cat(
        paste0(
          "Error: Must provide a valid list() object ",
          "in attribute.levels argument for type = 'constraints'\n"
        )
      )
    }
    # Calculate number of dimensions
    dimensions <- c()
    for (attr in names(attribute.levels)) {
      dimensions <- c(dimensions, length(attribute.levels[[attr]]))
    }
    # Initialize
    J_mat <- array(NA, dim = dimensions, dimnames = attribute.levels)

    # Fill in constrained cells with 0 probability
    for (cstr in constraints) {
      # Save the names of the constrained attributes
      constraint_names <- names(cstr)
      # Construct a call to select relevant rows
      select_call <- Quote(J_mat[])
      select_call <- select_call[c(1, 2, rep(3, length(dim(J_mat))))]
      for (f in 1:length(constraint_names)) {
        name <- constraint_names[f]
        index <- which(names(dimnames(J_mat)) == name)
        select_call[index + 2] <- cstr[f]
      }
      # Make a Call
      eval(call("<-", select_call, 0))
    }

    # If no randomization weights, then uniform marginal randomization
    if (is.null(level.probs)) {
      cell_prob <- 1 / sum(is.na(J_mat))
      J_mat[is.na(J_mat)] <- cell_prob
    } else {
      # Normalize level.probs to sum to 1
      for (attr in names(level.probs)) {
        level.probs[[attr]] <- level.probs[[attr]] / sum(level.probs[[attr]])
      }

      # If no names in level.probs, assume they're in order
      for (attr in names(level.probs)) {
        if (is.null(names(level.probs[[attr]]))) {
          names(level.probs[[attr]]) <- attribute.levels[[attr]]
        }
      }
      # If randomization weights specified: more calculations
      unconstrained_probs <- J_mat
      unconstrained_probs[TRUE] <- 1
      # For each Attribute
      for (attr in names(dimnames(J_mat))) {
        # For each level in each Attribute
        for (level in attribute.levels[[attr]]) {
          # Get a marginal probability
          marg_prob <- level.probs[[attr]][[level]]

          # Extract the rows pertaining to that marginal probability
          select_call <- Quote(unconstrained_probs[])
          select_call <- select_call[c(1, 2, rep(3, length(dim(J_mat))))]

          index <- which(names(dimnames(J_mat)) == attr)
          select_call[index + 2] <- level
          # Make a Call

          eval(call("<-", select_call, eval(call("*", select_call, marg_prob))))
        }
      }
      missing_prob <- sum(unconstrained_probs[is.na(J_mat) == FALSE])
      increase_prob <- unconstrained_probs * 1 / (1 - missing_prob)

      J_mat[is.na(J_mat)] <- increase_prob[is.na(J_mat)]
    }

    design.obj$J <- J_mat
    design.obj$dependence <- compute_dependencies(J_mat, tol)
  } else {
    cat(
      "Invalid type argument: Must be either 'file', 'array', or 'constraints"
    )
  }

  # Return design.obj if valid
  ## Make it a conjointDesign object
  class(design.obj) <- "conjointDesign"
  return(design.obj)
}
